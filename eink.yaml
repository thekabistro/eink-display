esphome:
  name: eink
  includes:
    - <vector>
    - <sstream>

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:
  level: DEBUG
  baud_rate: 115200

# Enable Home Assistant API
api:
  password: ""

ota:
  - platform: esphome
    password: ""

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Eink Fallback Hotspot"
    password: "S27YLtLSq60y"

captive_portal:

# HTTP Request component for OneBusAway API
http_request:
  id: http_request_data
  verify_ssl: false

# E-ink display configuration - Fixed pins for Waveshare HAT
spi:
  clk_pin: GPIO13
  mosi_pin: GPIO14

# Reference local font file
font:
  - file: "fonts/OpenSans-Bold.ttf"
    id: font_bold_small
    size: 25
  - file: "fonts/opensans.ttf"
    id: font_small
    size: 25
  - file: "fonts/opensans.ttf"
    id: font_medium
    size: 40
  - file: "fonts/opensans.ttf"
    id: font_large
    size: 100
  - file: "fonts/opensans.ttf"
    id: font_tiny
    size: 15
  - file: "fonts/opensans.ttf"
    id: font_date
    size: 40
  # Consolidate all icons into a single resource
  - file: "fonts/materialdesignicons-webfont.ttf"
    id: icon_font
    size: 100
    glyphs: &all_icons
      # Weather
      - "\U000F0590" # mdi-weather-cloudy
      - "\U000F0F2F" # mdi-weather-cloudy-alert
      - "\U000F0591" # mdi-weather-fog
      - "\U000F0592" # mdi-weather-hail
      - "\U000F0593" # mdi-weather-lightning
      - "\U000F067E" # mdi-weather-lightning-rainy
      - "\U000F0594" # mdi-weather-clear-night
      - "\U000F0595" # mdi-weather-partly-cloudy
      - "\U000F0596" # mdi-weather-pouring
      - "\U000F0597" # mdi-weather-rainy
      - "\U000F0598" # mdi-weather-snowy
      - "\U000F067F" # mdi-weather-snowy-rainy
      - "\U000F0599" # mdi-weather-sunny
      - "\U000F059D" # mdi-weather-windy
      - "\U000F059E" # mdi-weather-windy-variant
      # UI
      - "\U000F012C" # mdi-check-box-outline
      # Train Icons
      - "\U000F052C" # mdi-train
      - "\U000F08C4" # mdi-train-variant
      # Legend Icons
      - "\U000F004B" # mdi-arrow-down-drop-circle-outline
      - "\U000F0063" # mdi-arrow-up-drop-circle-outline
  - file: "fonts/materialdesignicons-webfont.ttf"
    id: icon_font_small
    size: 80
    glyphs: *all_icons
  - file: "fonts/materialdesignicons-webfont.ttf"
    id: icon_font_tiny
    size: 25
    glyphs: *all_icons
  - file: "fonts/materialdesignicons-webfont.ttf"
    id: icon_font_train
    size: 20
    glyphs: *all_icons

power_supply:
  - id: epaper_power
    pin: GPIO12
    enable_time: 500ms
    keep_on_time: 10s

display:
  - platform: waveshare_epaper
    id: my_display
    model: 7.50inV2alt
    cs_pin: GPIO15
    dc_pin: GPIO27
    busy_pin:
      number: GPIO25
      inverted: true
    reset_pin: GPIO26
    reset_duration: 2ms
    rotation: 270
    update_interval: 300s
    lambda: |-
      // Fill with black background
      it.fill(Color::BLACK);
      
      // Get display dimensions
      int width = it.get_width();
      int height = it.get_height();
      
      // Header
      int header_y = 38;
      auto time = id(time_sensor).now();
      if (time.is_valid()) {
        it.printf(30, header_y, id(font_tiny), Color::WHITE, TextAlign::TOP_LEFT, "%s", time.strftime("%I:%M %p").c_str());
      }
      
      if (id(train_positions).has_state()) {
        std::string pos_str = id(train_positions).state;
        std::stringstream pos_ss(pos_str);
        std::string segment;
        int train_count = 0;
        while(std::getline(pos_ss, segment, ',')) {
           train_count++;
        }
        it.printf(width - 55, header_y, id(font_tiny), Color::WHITE, TextAlign::TOP_RIGHT, "%d trains", train_count);
        it.printf(width - 30, header_y, id(icon_font_tiny), Color::WHITE, TextAlign::TOP_RIGHT, "\U000F012C");
      }

      // ROUTE LINE AND STATIONS
      int transit_start_y = 73;
      int transit_height = 600; // Fixed smaller height to squish stations
      int transit_end_y = transit_start_y + transit_height;
      int line_x = 320;

      // Legend Icons
      it.print(line_x - 15, header_y, id(icon_font_tiny), Color::WHITE, TextAlign::TOP_CENTER, "\U000F004B"); // Southbound
      it.print(line_x + 15, header_y, id(icon_font_tiny), Color::WHITE, TextAlign::TOP_CENTER, "\U000F0063"); // Northbound
      
      it.line(line_x, transit_start_y, line_x, transit_end_y, Color::WHITE);
      
      const char* station_names[] = {
        "Lynnwood City Center", "Mountlake Terrace", "Shoreline North/185th", "Shoreline South/148th",
        "Northgate", "Roosevelt", "U District", "University of Washington", "Capitol Hill",
        "Westlake", "Symphony", "Pioneer Square", "Int'l Dist/Chinatown", "Stadium", "SODO",
        "Beacon Hill", "Mount Baker", "Columbia City", "Othello", "Rainier Beach",
        "Tukwila Int'l Blvd", "SeaTac/Airport", "Angle Lake", "Kent Des Moines", "Star Lake", "Federal Way Downtown"
      };
      
      for (int i = 0; i < 26; i++) {
        int y = transit_start_y + (int)((float)i / 25.0 * transit_height);
        it.filled_circle(line_x, y, 3, Color::WHITE);
        it.print(240, y, id(font_tiny), Color::WHITE, TextAlign::CENTER_RIGHT, station_names[i]);
      }

      // REAL TRAIN DATA PARSING
      if (id(train_positions).has_state() && id(train_directions).has_state()) {
        std::string pos_str = id(train_positions).state;
        std::string dir_str = id(train_directions).state;

        std::vector<float> positions;
        std::stringstream pos_ss(pos_str);
        std::string segment;
        while(std::getline(pos_ss, segment, ',')) {
           positions.push_back(std::stof(segment));
        }

        std::vector<int> directions;
        std::stringstream dir_ss(dir_str);
        while(std::getline(dir_ss, segment, ',')) {
           directions.push_back(std::stoi(segment));
        }

        if (positions.size() == directions.size()) {
          for (size_t i = 0; i < positions.size(); ++i) {
            yield(); // Prevent WDT timeout
            
            float progress = positions[i];
            int direction = directions[i];

            int train_y = transit_start_y + (int)(progress * transit_height);
            int train_x = (direction == 1) ? line_x + 15 : line_x - 15;
            
            const char* icon = (direction == 1) ? "\U000F052C" : "\U000F08C4"; // up or down circle arrow
            it.print(train_x, train_y, id(icon_font_train), Color::WHITE, TextAlign::CENTER, icon);
          }
        } else {
          it.print(240, 750, id(font_tiny), Color::WHITE, TextAlign::CENTER, "Data Mismatch");
        }
      } else {
        it.print(240, 750, id(font_tiny), Color::WHITE, TextAlign::CENTER, "API: No State");
      }

# Sensors
sensor:
  - platform: uptime
    name: "E-Ink Transit Display Uptime"
    id: uptime_sensor
    update_interval: 300s

text_sensor:
  - platform: homeassistant
    id: train_positions
    entity_id: sensor.link_positions
    internal: true
  - platform: homeassistant
    id: train_directions
    entity_id: sensor.link_directions
    internal: true
    on_value:
      # Update the display whenever the second sensor updates
      then:
        - component.update: my_display

time:
  - platform: homeassistant
    id: time_sensor

button:
  - platform: template
    name: "Refresh E-Ink Display"
    on_press:
    - lambda: |-
        id(my_display).fill(Color::WHITE);
        id(my_display).update();
    - component.update: my_display