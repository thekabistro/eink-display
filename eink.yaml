esphome:
  name: eink
  includes:
    - <vector>
    - <sstream>

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:
  level: DEBUG
  baud_rate: 115200

# Enable Home Assistant API
api:
  password: ""

ota:
  - platform: esphome
    password: ""

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Eink Fallback Hotspot"
    password: "S27YLtLSq60y"

captive_portal:

# HTTP Request component for OneBusAway API
http_request:
  id: http_request_data
  verify_ssl: false

# E-ink display configuration - Fixed pins for Waveshare HAT
spi:
  clk_pin: GPIO13
  mosi_pin: GPIO14

# Reference local font file
font:
  - file: "fonts/OpenSans-Bold.ttf"
    id: font_bold_small
    size: 25
  - file: "fonts/opensans.ttf"
    id: font_small
    size: 25
  - file: "fonts/opensans.ttf"
    id: font_medium
    size: 40
  - file: "fonts/opensans.ttf"
    id: font_large
    size: 100
  - file: "fonts/opensans.ttf"
    id: font_tiny
    size: 15
  - file: "fonts/opensans.ttf"
    id: font_date
    size: 40
  # Include Material Design Icons font with specified glyphs
  - file: "fonts/materialdesignicons-webfont.ttf"
    id: icon_font
    size: 100
    glyphs: &weather_glyphs
      - "\U000F0590" # mdi-weather-cloudy
      - "\U000F0F2F" # mdi-weather-cloudy-alert
      - "\U000F0591" # mdi-weather-fog
      - "\U000F0592" # mdi-weather-hail
      - "\U000F0593" # mdi-weather-lightning
      - "\U000F067E" # mdi-weather-lightning-rainy
      - "\U000F0594" # mdi-weather-clear-night
      - "\U000F0595" # mdi-weather-partly-cloudy
      - "\U000F0596" # mdi-weather-pouring
      - "\U000F0597" # mdi-weather-rainy
      - "\U000F0598" # mdi-weather-snowy
      - "\U000F067F" # mdi-weather-snowy-rainy
      - "\U000F0599" # mdi-weather-sunny
      - "\U000F059D" # mdi-weather-windy
      - "\U000F059E" # mdi-weather-windy-variant
  - file: "fonts/materialdesignicons-webfont.ttf"
    id: icon_font_small
    size: 80
    glyphs: *weather_glyphs

power_supply:
  - id: epaper_power
    pin: GPIO12
    enable_time: 500ms
    keep_on_time: 10s

display:
  - platform: waveshare_epaper
    id: my_display
    model: 7.50inV2alt
    cs_pin: GPIO15
    dc_pin: GPIO27
    busy_pin: GPIO25
    reset_pin: GPIO26
    reset_duration: 2ms
    rotation: 270
    update_interval: 300s
    lambda: |-
      // Fill with black background
      it.fill(Color::BLACK);
      
      // Get display dimensions
      int width = it.get_width();
      int height = it.get_height();
      
      // Draw header section with date and time
      auto time = id(time_sensor).now();
      if (time.is_valid()) {
        it.printf(width/2, 20, id(font_small), Color::WHITE, TextAlign::TOP_CENTER, "%s, %s %d%s",
          time.strftime("%A").c_str(),
          time.strftime("%B").c_str(),
          time.day_of_month,
          (time.day_of_month % 10 == 1 && time.day_of_month != 11) ? "st" :
          (time.day_of_month % 10 == 2 && time.day_of_month != 12) ? "nd" :
          (time.day_of_month % 10 == 3 && time.day_of_month != 13) ? "rd" : "th"
        );
        it.printf(width/2, 45, id(font_medium), Color::WHITE, TextAlign::TOP_CENTER, "%s", time.strftime("%I:%M %p").c_str());
      }
      
      // Draw header separator line
      it.line(30, 90, width-30, 90, Color::WHITE);
      
      // ROUTE LINE AND STATIONS
      int transit_start_y = 100;
      int transit_end_y = 750;
      int transit_height = transit_end_y - transit_start_y;
      int line_x = 320;
      
      it.line(line_x, transit_start_y, line_x, transit_end_y, Color::WHITE);
      
      const char* station_names[] = {
        "Lynnwood City Center", "Mountlake Terrace", "Shoreline North/185th", "Shoreline South/148th",
        "Northgate", "Roosevelt", "U District", "University of Washington", "Capitol Hill",
        "Westlake", "Symphony", "Pioneer Square", "Int'l Dist/Chinatown", "Stadium", "SODO",
        "Beacon Hill", "Mount Baker", "Columbia City", "Othello", "Rainier Beach",
        "Tukwila Int'l Blvd", "SeaTac/Airport", "Angle Lake"
      };
      
      for (int i = 0; i < 23; i++) {
        int y = transit_start_y + (int)((float)i / 22.0 * transit_height);
        it.filled_circle(line_x, y, 3, Color::WHITE);
        it.print(240, y, id(font_tiny), Color::WHITE, TextAlign::CENTER_RIGHT, station_names[i]);
      }

      // REAL TRAIN DATA PARSING
      if (id(train_positions).has_state() && id(train_directions).has_state()) {
        std::string pos_str = id(train_positions).state;
        std::string dir_str = id(train_directions).state;

        std::vector<float> positions;
        std::stringstream pos_ss(pos_str);
        std::string segment;
        while(std::getline(pos_ss, segment, ',')) {
           positions.push_back(std::stof(segment));
        }

        std::vector<int> directions;
        std::stringstream dir_ss(dir_str);
        while(std::getline(dir_ss, segment, ',')) {
           directions.push_back(std::stoi(segment));
        }

        if (positions.size() == directions.size()) {
          for (size_t i = 0; i < positions.size(); ++i) {
            yield(); // Prevent WDT timeout
            
            float progress = positions[i];
            int direction = directions[i];

            int train_y = transit_start_y + (int)(progress * transit_height);
            int train_x = (direction == 1) ? line_x + 20 : line_x - 20;

            it.filled_rectangle(train_x - 8, train_y - 4, 16, 8, Color::WHITE);
          }
          it.printf(240, 765, id(font_tiny), Color::WHITE, TextAlign::CENTER, "%d trains", positions.size());
        } else {
          it.print(240, 750, id(font_tiny), Color::WHITE, TextAlign::CENTER, "Data Mismatch");
        }
      } else {
        it.print(240, 750, id(font_tiny), Color::WHITE, TextAlign::CENTER, "API: No State");
      }

# Sensors
sensor:
  - platform: uptime
    name: "E-Ink Transit Display Uptime"
    id: uptime_sensor
    update_interval: 60s

text_sensor:
  - platform: homeassistant
    id: train_positions
    entity_id: sensor.train_positions
    internal: true
  - platform: homeassistant
    id: train_directions
    entity_id: sensor.train_directions
    internal: true
    on_value:
      # Update the display whenever the second sensor updates
      then:
        - component.update: my_display

time:
  - platform: homeassistant
    id: time_sensor

button:
  - platform: template
    name: "Refresh E-Ink Display"
    on_press:
    - lambda: |-
        id(my_display).fill(Color::WHITE);
        id(my_display).update();
    - component.update: my_display