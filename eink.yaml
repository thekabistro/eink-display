esphome:
  name: eink

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:
  level: DEBUG
  baud_rate: 115200

# Enable Home Assistant API
api:
  password: ""

ota:
  - platform: esphome
    password: ""

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Eink Fallback Hotspot"
    password: "S27YLtLSq60y"

captive_portal:

# HTTP Request component for OneBusAway API
http_request:
  id: http_request_data
  verify_ssl: false

# E-ink display configuration - Fixed pins for Waveshare HAT
spi:
  clk_pin: GPIO13
  mosi_pin: GPIO14

# Reference local font file
font:
  - file: "fonts/OpenSans-Bold.ttf"
    id: font_bold_small
    size: 25
  - file: "fonts/opensans.ttf"
    id: font_small
    size: 25
  - file: "fonts/opensans.ttf"
    id: font_medium
    size: 40
  - file: "fonts/opensans.ttf"
    id: font_large
    size: 100
  - file: "fonts/opensans.ttf"
    id: font_tiny
    size: 15
  - file: "fonts/opensans.ttf"
    id: font_date
    size: 40
  # Include Material Design Icons font with specified glyphs
  - file: "fonts/materialdesignicons-webfont.ttf"
    id: icon_font
    size: 100
    glyphs: &weather_glyphs
      - "\U000F0590" # mdi-weather-cloudy
      - "\U000F0F2F" # mdi-weather-cloudy-alert
      - "\U000F0591" # mdi-weather-fog
      - "\U000F0592" # mdi-weather-hail
      - "\U000F0593" # mdi-weather-lightning
      - "\U000F067E" # mdi-weather-lightning-rainy
      - "\U000F0594" # mdi-weather-clear-night
      - "\U000F0595" # mdi-weather-partly-cloudy
      - "\U000F0596" # mdi-weather-pouring
      - "\U000F0597" # mdi-weather-rainy
      - "\U000F0598" # mdi-weather-snowy
      - "\U000F067F" # mdi-weather-snowy-rainy
      - "\U000F0599" # mdi-weather-sunny
      - "\U000F059D" # mdi-weather-windy
      - "\U000F059E" # mdi-weather-windy-variant
  - file: "fonts/materialdesignicons-webfont.ttf"
    id: icon_font_small
    size: 80
    glyphs: *weather_glyphs

power_supply:
  - id: epaper_power
    pin: GPIO12
    enable_time: 500ms
    keep_on_time: 10s

display:
  - platform: waveshare_epaper
    id: my_display
    model: 7.50inV2alt
    cs_pin: GPIO15
    dc_pin: GPIO27
    busy_pin: GPIO25
    reset_pin: GPIO26
    reset_duration: 2ms
    rotation: 270
    update_interval: 300s

    lambda: |-
      // Fill with black background
      it.fill(Color::BLACK);
      
      // Get display dimensions (confirmed: 480x800)
      int width = it.get_width();
      int height = it.get_height();
      
      // Draw header section with date and time
      auto time = id(time_sensor).now();
      if (time.is_valid()) {
        // Helper functions
        auto get_weekday_name = [](int day_of_week) -> const char* {
          const char* weekdays[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
          int corrected_day = (day_of_week + 6) % 7;  // ESPHome adjustment
          return weekdays[corrected_day];
        };
        
        auto get_month_name = [](int month) -> const char* {
          const char* months[] = {"January", "February", "March", "April", "May", "June", "July", 
                                 "August", "September", "October", "November", "December"};
          return months[month - 1];
        };
        
        auto get_ordinal_suffix = [](int day) -> const char* {
          if (day == 1 || day == 21 || day == 31) return "st";
          if (day == 2 || day == 22) return "nd";
          if (day == 3 || day == 23) return "rd";
          return "th";
        };
        
        // Format date string
        std::string date_str = std::string(get_weekday_name(time.day_of_week)) + ", " + 
                              get_month_name(time.month) + " " + 
                              std::to_string(time.day_of_month) + 
                              get_ordinal_suffix(time.day_of_month);
        
        // Draw date
        it.print(width/2, 20, id(font_small), Color::WHITE, TextAlign::TOP_CENTER, date_str.c_str());
        
        // Format and draw time
        int display_hour = time.hour % 12 == 0 ? 12 : time.hour % 12;
        const char *am_pm = time.hour >= 12 ? "PM" : "AM";
        std::string time_str = std::to_string(display_hour) + ":" + 
                              (time.minute < 10 ? "0" : "") + 
                              std::to_string(time.minute) + " " + am_pm;
        it.print(width/2, 45, id(font_medium), Color::WHITE, TextAlign::TOP_CENTER, time_str.c_str());
      }
      
      // Draw header separator line
      it.line(30, 90, width-30, 90, Color::WHITE);
      
      // ROUTE LINE AND STATIONS
      // Transit area: from y=100 to y=750 (650 pixels total)
      int transit_start_y = 100;
      int transit_end_y = 750;
      int transit_height = transit_end_y - transit_start_y;
      int line_x = 320; // Vertical line position - moved much further right
      
      // Draw main vertical route line
      it.line(line_x, transit_start_y, line_x, transit_end_y, Color::WHITE);
      
      // Station data: name and Y position
      struct Station {
        const char* name;
        int y;
      };
      
      // Calculate Y positions for 23 stations evenly spaced
      Station stations[23] = {
        {"Lynnwood City Center", transit_start_y + (transit_height * 0 / 22)},
        {"Mountlake Terrace", transit_start_y + (transit_height * 1 / 22)},
        {"Shoreline North/185th", transit_start_y + (transit_height * 2 / 22)},
        {"Shoreline South/148th", transit_start_y + (transit_height * 3 / 22)},
        {"Northgate", transit_start_y + (transit_height * 4 / 22)},
        {"Roosevelt", transit_start_y + (transit_height * 5 / 22)},
        {"U District", transit_start_y + (transit_height * 6 / 22)},
        {"University of Washington", transit_start_y + (transit_height * 7 / 22)},
        {"Capitol Hill", transit_start_y + (transit_height * 8 / 22)},
        {"Westlake", transit_start_y + (transit_height * 9 / 22)},
        {"Symphony", transit_start_y + (transit_height * 10 / 22)},
        {"Pioneer Square", transit_start_y + (transit_height * 11 / 22)},
        {"Int'l Dist/Chinatown", transit_start_y + (transit_height * 12 / 22)},
        {"Stadium", transit_start_y + (transit_height * 13 / 22)},
        {"SODO", transit_start_y + (transit_height * 14 / 22)},
        {"Beacon Hill", transit_start_y + (transit_height * 15 / 22)},
        {"Mount Baker", transit_start_y + (transit_height * 16 / 22)},
        {"Columbia City", transit_start_y + (transit_height * 17 / 22)},
        {"Othello", transit_start_y + (transit_height * 18 / 22)},
        {"Rainier Beach", transit_start_y + (transit_height * 19 / 22)},
        {"Tukwila Int'l Blvd", transit_start_y + (transit_height * 20 / 22)},
        {"SeaTac/Airport", transit_start_y + (transit_height * 21 / 22)},
        {"Angle Lake", transit_start_y + (transit_height * 22 / 22)}
      };
      
      // Draw all stations
      for (int i = 0; i < 23; i++) {
        // Draw station dot (circle) on the main line
        it.filled_circle(line_x, stations[i].y, 3, Color::WHITE);
        
        // Draw station name at fixed position (not relative to line_x)
        it.print(240, stations[i].y, id(font_tiny), Color::WHITE, TextAlign::CENTER_RIGHT, stations[i].name);
      }
      
      // REAL TRAIN DATA - Step 4
      // Station name to position mapping (0.0 = north, 1.0 = south)
      std::map<std::string, float> station_positions = {
        {"Lynnwood City Center", 0.0f}, {"Mountlake Terrace", 0.045f}, 
        {"Shoreline North/185th", 0.091f}, {"Shoreline South/148th", 0.136f},
        {"Northgate", 0.182f}, {"Roosevelt", 0.227f}, {"U District", 0.273f},
        {"University of Washington", 0.318f}, {"Capitol Hill", 0.364f}, 
        {"Westlake", 0.409f}, {"Symphony", 0.455f}, {"Pioneer Square", 0.5f},
        {"Int'l Dist/Chinatown", 0.545f}, {"Stadium", 0.591f}, {"SODO", 0.636f},
        {"Beacon Hill", 0.682f}, {"Mount Baker", 0.727f}, {"Columbia City", 0.773f},
        {"Othello", 0.818f}, {"Rainier Beach", 0.864f}, {"Tukwila Int'l Blvd", 0.909f},
        {"SeaTac/Airport", 0.955f}, {"Angle Lake", 1.0f}
      };
      
      // Debug API component status at bottom
      if (id(train_data).has_state()) {
        std::string status = id(train_data).state;
        it.print(240, 740, id(font_tiny), Color::WHITE, TextAlign::CENTER, "API: OK");
        it.print(240, 755, id(font_tiny), Color::WHITE, TextAlign::CENTER, status.c_str());
      } else {
        it.print(240, 740, id(font_tiny), Color::WHITE, TextAlign::CENTER, "API: No State");
        // Show more debug info
        it.print(240, 755, id(font_tiny), Color::WHITE, TextAlign::CENTER, "Sensor not ready");
      }
      
      // Also show if HTTP component exists
      it.print(240, 770, id(font_tiny), Color::WHITE, TextAlign::CENTER, "HTTP: Ready");
      
      // FALLBACK: Mock data when API not available
      struct MockTrain {
        const char* id;
        bool northbound;
        float position;
      };
      
      MockTrain fallback_trains[] = {
        {"T1", true, 0.15}, {"T2", false, 0.35}, {"T3", true, 0.52},
        {"T4", false, 0.78}, {"T5", true, 0.91}
      };
      
      int num_trains = sizeof(fallback_trains) / sizeof(MockTrain);
      
      // Draw trains (mock data for now)
      for (int i = 0; i < num_trains; i++) {
        MockTrain train = fallback_trains[i];
        
        int train_y = transit_start_y + (int)(train.position * transit_height);
        int train_x = train.northbound ? line_x + 20 : line_x - 20;
        
        std::string train_label = std::string(train.id) + (train.northbound ? "N" : "S");
        it.print(train_x, train_y, id(font_tiny), Color::WHITE, TextAlign::CENTER, train_label.c_str());
      }

# Sensors
sensor:
  - platform: uptime
    name: "E-Ink Transit Display Uptime"
    id: uptime_sensor
    update_interval: 60s

text_sensor:
  - platform: template
    name: "E-Ink Transit Display Status"
    id: display_status
    update_interval: 60s
    lambda: |-
      return {"Last update: " + id(time_sensor).now().strftime("%H:%M:%S")};
    internal: false
    
  - platform: template
    name: "OneBusAway Train Data"
    id: train_data
    update_interval: 120s  # Update every 2 minutes
    internal: true
    lambda: |-
      // For now, return a placeholder until we get HTTP working
      // Will add actual API call in display lambda instead
      return {"API Setup Ready"};

time:
  - platform: homeassistant
    id: time_sensor

button:
  - platform: template
    name: "Refresh E-Ink Display"
    on_press:
    - lambda: |-
        id(my_display).fill(Color::WHITE);
        id(my_display).update();
    - component.update: my_display