esphome:
  name: eink

esp32:
  board: esp32dev
  framework:
    type: arduino

# Enable logging
logger:
  level: DEBUG
  baud_rate: 115200

# Enable Home Assistant API
api:
  password: ""

ota:
  - platform: esphome
    password: ""

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Eink Fallback Hotspot"
    password: "S27YLtLSq60y"

captive_portal:

# E-ink display configuration - Fixed pins for Waveshare HAT
spi:
  clk_pin: GPIO13
  mosi_pin: GPIO14

# Reference local font file
font:
  - file: "fonts/OpenSans-Bold.ttf"
    id: font_bold_small
    size: 25
  - file: "fonts/opensans.ttf"
    id: font_small
    size: 25
  - file: "fonts/opensans.ttf"
    id: font_medium
    size: 40
  - file: "fonts/opensans.ttf"
    id: font_large
    size: 100
  - file: "fonts/opensans.ttf"
    id: font_tiny
    size: 15
  - file: "fonts/opensans.ttf"
    id: font_date
    size: 40
  # Include Material Design Icons font with specified glyphs
  - file: "fonts/materialdesignicons-webfont.ttf"
    id: icon_font
    size: 100
    glyphs: &weather_glyphs
      - "\U000F0590" # mdi-weather-cloudy
      - "\U000F0F2F" # mdi-weather-cloudy-alert
      - "\U000F0591" # mdi-weather-fog
      - "\U000F0592" # mdi-weather-hail
      - "\U000F0593" # mdi-weather-lightning
      - "\U000F067E" # mdi-weather-lightning-rainy
      - "\U000F0594" # mdi-weather-clear-night
      - "\U000F0595" # mdi-weather-partly-cloudy
      - "\U000F0596" # mdi-weather-pouring
      - "\U000F0597" # mdi-weather-rainy
      - "\U000F0598" # mdi-weather-snowy
      - "\U000F067F" # mdi-weather-snowy-rainy
      - "\U000F0599" # mdi-weather-sunny
      - "\U000F059D" # mdi-weather-windy
      - "\U000F059E" # mdi-weather-windy-variant
  - file: "fonts/materialdesignicons-webfont.ttf"
    id: icon_font_small
    size: 80
    glyphs: *weather_glyphs

power_supply:
  - id: epaper_power
    pin: GPIO12
    enable_time: 500ms
    keep_on_time: 10s

display:
  - platform: waveshare_epaper
    id: my_display
    model: 7.50inV2
    cs_pin: GPIO15
    dc_pin: GPIO27
    busy_pin: GPIO25
    reset_pin: GPIO26
    reset_duration: 2ms
    rotation: 0
    update_interval: 300s

    lambda: |-
      // Helper function to get weather icon
      auto get_weather_icon = [](const std::string& condition) -> const char* {
        std::string cond = condition;
        for (auto & c: cond) c = tolower(c);
        
        if (cond.find("clear-night") != std::string::npos) return "\U000F0594";
        if (cond.find("cloudy") != std::string::npos) return "\U000F0590";
        if (cond.find("fog") != std::string::npos) return "\U000F0591";
        if (cond.find("hail") != std::string::npos) return "\U000F0592";
        if (cond.find("lightning") != std::string::npos) return "\U000F0593";
        if (cond.find("rainy") != std::string::npos) return "\U000F0597";
        if (cond.find("pouring") != std::string::npos) return "\U000F0596";
        if (cond.find("snowy") != std::string::npos) return "\U000F0598";
        if (cond.find("sunny") != std::string::npos) return "\U000F0599";
        if (cond.find("windy") != std::string::npos) return "\U000F059D";
        if (cond.find("partlycloudy") != std::string::npos) return "\U000F0595";
        return "\U000F0F2F"; // default
      };
      
      // Helper function to get ordinal suffix
      auto get_ordinal_suffix = [](int day) -> const char* {
        if (day == 1 || day == 21 || day == 31) return "st";
        if (day == 2 || day == 22) return "nd";
        if (day == 3 || day == 23) return "rd";
        return "th";
      };
      
      // Helper function to get weekday name
      auto get_weekday_name = [](int day_of_week) -> const char* {
        const char* weekdays[] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
        int corrected_day = (day_of_week + 6) % 7;  // ESPHome adjustment
        return weekdays[corrected_day];
      };
      
      // Helper function to get month name
      auto get_month_name = [](int month) -> const char* {
        const char* months[] = {"January", "February", "March", "April", "May", "June", "July", 
                               "August", "September", "October", "November", "December"};
        return months[month - 1];
      };
      
      // Helper function to format 12-hour time
      auto format_12_hour_time = [](int hour, int minute) -> std::string {
        int display_hour = hour % 12 == 0 ? 12 : hour % 12;
        const char *am_pm = hour >= 12 ? "PM" : "AM";
        return std::to_string(display_hour) + ":" + (minute < 10 ? "0" : "") + std::to_string(minute) + " " + am_pm;
      };
      
      // Helper function to draw forecast hour
      auto draw_forecast_hour = [&](int x, const std::string& datetime_str, const std::string& condition, float temp, int hour_offset) {
        const int base_y = 215;
        const int icon_offset = 70;
        const int temp_offset = 140;
        
        // Parse and display hour
        if (!datetime_str.empty()) {
          struct tm tm = {};
          strptime(datetime_str.c_str(), "%Y-%m-%dT%H:%M:%S%z", &tm);
          int display_hour = tm.tm_hour % 12 == 0 ? 12 : tm.tm_hour % 12;
          std::string hour_str = std::to_string(display_hour) + (tm.tm_hour >= 12 ? " PM" : " AM");
          it.print(x, base_y, id(font_medium), Color::WHITE, TextAlign::TOP_CENTER, hour_str.c_str());
        } else {
          std::string fallback = "+" + std::to_string(hour_offset) + "h";
          it.print(x, base_y, id(font_medium), Color::WHITE, TextAlign::TOP_CENTER, fallback.c_str());
        }
        
        // Draw weather icon
        const char* icon = get_weather_icon(condition);
        it.print(x, base_y + icon_offset, id(icon_font_small), Color::WHITE, TextAlign::TOP_CENTER, icon);
        
        // Draw temperature
        char temp_str[16];
        sprintf(temp_str, "%.0fÂ°", temp);
        it.print(x, base_y + temp_offset, id(font_medium), Color::WHITE, TextAlign::TOP_CENTER, temp_str);
      };

      // Macro to generate sensor access at compile time
      #define GET_HOUR_CONDITION(n) id(forecast_hour##n##_condition)
      #define GET_HOUR_TEMP(n) id(forecast_hour##n##_temp)
      #define GET_HOUR_DATETIME(n) id(forecast_hour##n##_datetime)
      
      // Macro to draw a forecast hour
      #define DRAW_FORECAST_HOUR(hour_num) \
        do { \
          if (GET_HOUR_CONDITION(hour_num).has_state() && GET_HOUR_TEMP(hour_num).has_state()) { \
            int x = first_hour_x + ((hour_num - 1) * forecast_spacing); \
            std::string datetime_str = GET_HOUR_DATETIME(hour_num).has_state() ? GET_HOUR_DATETIME(hour_num).state : ""; \
            draw_forecast_hour(x, datetime_str, GET_HOUR_CONDITION(hour_num).state, GET_HOUR_TEMP(hour_num).state, hour_num); \
          } \
        } while(0)

      // Fill with black background
      it.fill(Color::BLACK);
      
      // Draw date and time
      auto time = id(time_sensor).now();
      if (time.is_valid()) {
        // Format date string using helper functions
        std::string date_str = std::string(get_weekday_name(time.day_of_week)) + ", " + 
                              get_month_name(time.month) + " " + 
                              std::to_string(time.day_of_month) + 
                              get_ordinal_suffix(time.day_of_month);
        
        // Draw the date centered at the top
        it.print(385, 30, id(font_date), Color::WHITE, TextAlign::TOP_CENTER, date_str.c_str());
        
        // Format and draw time using helper function
        std::string time_str = format_12_hour_time(time.hour, time.minute);
        it.print(385, 70, id(font_large), Color::WHITE, TextAlign::TOP_CENTER, time_str.c_str());
        
        // Draw horizontal line
        it.line(85, 200, 685, 200, Color::WHITE);
      }
      
      // HOURLY FORECAST SECTION - Simple and clean
      const int first_hour_x = 180;
      const int forecast_spacing = 135;
      
      // Draw all forecast hours - clean and direct
      DRAW_FORECAST_HOUR(1);
      DRAW_FORECAST_HOUR(2);
      DRAW_FORECAST_HOUR(3);
      DRAW_FORECAST_HOUR(4);
      
      // Draw outer border
      it.rectangle(50, 0, 700, 480, Color::WHITE);
      
      // Debug info
      if (id(forecast_hour1_datetime).has_state()) {
        it.printf(45, 565, id(font_tiny), Color::WHITE, TextAlign::BOTTOM_LEFT, "Hour1: %s", id(forecast_hour1_datetime).state.c_str());
      } else {
        it.printf(45, 565, id(font_tiny), Color::WHITE, TextAlign::BOTTOM_LEFT, "Hour1 datetime unavailable");
      }
      
      if (id(forecast_hour1_condition).has_state()) {
        it.printf(45, 580, id(font_tiny), Color::WHITE, TextAlign::BOTTOM_LEFT, "Condition: %s", id(forecast_hour1_condition).state.c_str());
      } else {
        it.printf(45, 580, id(font_tiny), Color::WHITE, TextAlign::BOTTOM_LEFT, "Hour1 condition unavailable");
      }

      // Clean up macros
      #undef GET_HOUR_CONDITION
      #undef GET_HOUR_TEMP  
      #undef GET_HOUR_DATETIME
      #undef DRAW_FORECAST_HOUR

# Sensors
sensor:
  - platform: uptime
    name: "E-Ink Display Uptime"
    id: uptime_sensor
    update_interval: 60s
    
  - platform: homeassistant
    id: weather_temperature
    entity_id: weather.forecast_home
    attribute: temperature
    internal: true
    
  - platform: homeassistant
    id: weather_humidity
    entity_id: weather.forecast_home
    attribute: humidity
    internal: true
    
  - platform: homeassistant
    id: weather_wind_speed
    entity_id: weather.forecast_home
    attribute: wind_speed
    internal: true
    
  - platform: homeassistant
    id: weather_wind_bearing
    entity_id: weather.forecast_home
    attribute: wind_bearing
    internal: true
    
  - platform: homeassistant
    id: weather_pressure
    entity_id: weather.forecast_home
    attribute: pressure
    internal: true
    
  # Forecast temperature sensors - using YAML anchors for DRY principle
  - &forecast_temp_template
    platform: homeassistant
    id: forecast_hour1_temp
    entity_id: sensor.forecast_hour_1_temperature
    internal: true
    
  - <<: *forecast_temp_template
    id: forecast_hour2_temp
    entity_id: sensor.forecast_hour_2_temperature
    
  - <<: *forecast_temp_template
    id: forecast_hour3_temp
    entity_id: sensor.forecast_hour_3_temperature
    
  - <<: *forecast_temp_template
    id: forecast_hour4_temp
    entity_id: sensor.forecast_hour_4_temperature

text_sensor:
  - platform: homeassistant
    id: weather_condition
    entity_id: weather.forecast_home
    internal: true
    
  - platform: homeassistant
    id: weather_temperature_unit
    entity_id: weather.forecast_home
    attribute: temperature_unit
    internal: true
    
  - platform: homeassistant
    id: weather_wind_speed_unit
    entity_id: weather.forecast_home
    attribute: wind_speed_unit
    internal: true
    
  - platform: homeassistant
    id: weather_pressure_unit
    entity_id: weather.forecast_home
    attribute: pressure_unit
    internal: true
    
  - platform: template
    name: "E-Ink Display Status"
    id: display_status
    update_interval: 60s
    lambda: |-
      return {"Last update: " + id(time_sensor).now().strftime("%H:%M:%S")};
    internal: false
    
  # Forecast text sensors - using YAML anchors for DRY principle
  - &forecast_condition_template
    platform: homeassistant
    id: forecast_hour1_condition
    entity_id: sensor.forecast_hour_1_condition
    internal: true
    
  - <<: *forecast_condition_template
    id: forecast_hour2_condition
    entity_id: sensor.forecast_hour_2_condition
    
  - <<: *forecast_condition_template
    id: forecast_hour3_condition
    entity_id: sensor.forecast_hour_3_condition
    
  - <<: *forecast_condition_template
    id: forecast_hour4_condition
    entity_id: sensor.forecast_hour_4_condition
    
  - &forecast_datetime_template
    platform: homeassistant
    id: forecast_hour1_datetime
    entity_id: sensor.forecast_hour_1_time
    internal: true
    
  - <<: *forecast_datetime_template
    id: forecast_hour2_datetime
    entity_id: sensor.forecast_hour_2_time
    
  - <<: *forecast_datetime_template
    id: forecast_hour3_datetime
    entity_id: sensor.forecast_hour_3_time
    
  - <<: *forecast_datetime_template
    id: forecast_hour4_datetime
    entity_id: sensor.forecast_hour_4_time

time:
  - platform: homeassistant
    id: time_sensor

button:
  - platform: template
    name: "Refresh E-Ink Display"
    on_press:
    - lambda: |-
        id(my_display).fill(Color::WHITE);
        id(my_display).update();
    - component.update: my_display